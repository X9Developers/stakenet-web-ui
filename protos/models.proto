syntax = "proto3";

package io.stakenet.orderbook.protos;

// A non-negative Big Integer represented as string, like "100000000"
message BigInteger {
    string value = 1;
}

// The details for an order that's not tied to a trading pair
message OrderDetails {
    string orderId = 1; // the order unique identifier (must be a UUID without hyphens)
    BigInteger funds = 2; // the funds willing to trade, represented in the currency you own. For example XSN_BTC: in BUY order is in BTC, in SELL order is in XSN
    BigInteger price = 3; // only for limit orders, it must not be present on a market order, otherwise, decoding on the server fails, for example, 20000000 for XSN_LTC means that 1 XSN = 20000000 Litoshis
}

message Order {
    string tradingPair = 1;
    OrderType type = 2;
    OrderSide side = 3;
    OrderDetails details = 4;

    enum OrderType {
        limit = 0;
        market = 1;
    }

    enum OrderSide {
        buy = 0;
        sell = 1;
    }
}

// A trade represents two orders that were matched, they operate on the same trading pair
message Trade {
    string id = 1; // the unique trade identifier
    string tradingPair = 2; // The trading pair for the matched orders, like XSN_BTC
    BigInteger price = 3; // The agreed price for the trade, for XSN_BTC, the price is in BTC
    BigInteger size = 4; // The trade size, for XSN_BTC, the size is in XSN
    string existingOrderId = 5; // The order that was present on the orderbook before the trade
    string executingOrderId = 6; // The order placed to the orderbook that executed the trade
    string executingOrderSide = 7; // The side of the new executing order
    int64 executedOn = 8; // the timestamp when the orders where matched into a trade
    BigInteger existingOrderFunds = 9; // The existing funds, the same amount received on the place order.
}

message BarPrices {
    int64 time = 1; // the timestamp of the corresponding prices in ms
    BigInteger open = 2; // the price of the first matched order of the day
    BigInteger high = 3; // the highest price of the day
    BigInteger low = 4; // the lowest price of the day
    BigInteger close = 5; // the price of the last matched order of the day
    int64 volume = 6; // the volume is the number of trades on that interval
}

// Interval [from, to], both being inclusive
message BigInclusiveInterval {
    BigInteger from = 1;
    BigInteger to = 2;
}

message TradingPair {
    string principal = 2; // represents the principal currency
    string secondary = 1; // represents the secondary currency
    string id = 3; // The union of both currencies, Example BTC_XSN
    BigInclusiveInterval buyFundsInterval = 4; // the valid funds for buy orders
    BigInclusiveInterval buyPriceInterval = 5; // the valid price for buy orders
    BigInclusiveInterval sellFundsInterval = 6; // the valid funds for sell orders
    BigInclusiveInterval sellPriceInterval = 7; // the valid price for sell orders
    string buyFeePercent = 8; // the fee percentage on buy orders, encoded as string to keep precision
    string sellFeePercent = 9; // the fee percentage on sell orders, encoded as string to keep precision
}

message RefundablePayment {
    BigInteger paidAmount = 1; // The paid amount for the given payment hash, necessary to validate with the payment hash.
    bytes paymentHash = 2; //  The 32 bytes raw payment_hash that has been paid.
}

// The intention is to get the open orders grouped by price
message OrderSummary {
    BigInteger price = 1; // The price represented in the principal currency of the trading pair, for example, 20000000 for XSN_LTC means that 1 XSN = 20000000 Litoshis
    BigInteger amount = 2; // The sum of funds for the given price.
}

// This is used by CommandFailed to indicate that the command failed due to a server maintenance
message ServerInMaintenance {}

message RentedChannel {
    oneof value {
        LndChannel lndChannel = 1;
        ConnextChannel connextChannel = 2;
    }
}

message LndChannel {
    bytes nodePublicKey = 1; // the wallet's public key to open the channel to
    string channelId = 2; // the id generated by orderbook
    bytes fundingTransaction = 3; // the funding transaction
    int32 outputIndex = 4; // the output index
    string fundingTxidStr = 5; // the hex string funding transaction id
}

message ConnextChannel {
    string nodePublicIdentifier = 1; // the wallet's public identifier to open the channel to
    string channelId = 2; // the id generated by orderbook
    string channelAddress = 3; // the address of the opened channel
}

enum SendingSide {
    client = 0;
    pool = 1;
}
